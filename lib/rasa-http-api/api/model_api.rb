=begin
#Rasa - Server Endpoints

#The Rasa server provides endpoints to retrieve trackers of conversations as well as endpoints to modify them. Additionally, endpoints for training and testing models are provided.

The version of the OpenAPI document: 1.0.0

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 6.2.1

=end

require 'cgi'

module Rasa::HTTP
  class ModelApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Parse a message using the Rasa model
    # Predicts the intent and entities of the message posted to this endpoint. No messages will be stored to a conversation and no action will be run. This will just retrieve the NLU parse results.
    # @param parse_model_message_request [ParseModelMessageRequest] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :emulation_mode Specify the emulation mode to use. Emulation mode transforms the response JSON to the format expected by the service specified as the emulation_mode. Requests must still be sent in the regular Rasa format.
    # @return [ParseResult]
    def parse_model_message(parse_model_message_request, opts = {})
      data, _status_code, _headers = parse_model_message_with_http_info(parse_model_message_request, opts)
      data
    end

    # Parse a message using the Rasa model
    # Predicts the intent and entities of the message posted to this endpoint. No messages will be stored to a conversation and no action will be run. This will just retrieve the NLU parse results.
    # @param parse_model_message_request [ParseModelMessageRequest] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :emulation_mode Specify the emulation mode to use. Emulation mode transforms the response JSON to the format expected by the service specified as the emulation_mode. Requests must still be sent in the regular Rasa format.
    # @return [Array<(ParseResult, Integer, Hash)>] ParseResult data, response status code and response headers
    def parse_model_message_with_http_info(parse_model_message_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ModelApi.parse_model_message ...'
      end
      # verify the required parameter 'parse_model_message_request' is set
      if @api_client.config.client_side_validation && parse_model_message_request.nil?
        fail ArgumentError, "Missing the required parameter 'parse_model_message_request' when calling ModelApi.parse_model_message"
      end
      allowable_values = ["WIT", "LUIS", "DIALOGFLOW"]
      if @api_client.config.client_side_validation && opts[:'emulation_mode'] && !allowable_values.include?(opts[:'emulation_mode'])
        fail ArgumentError, "invalid value for \"emulation_mode\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/model/parse'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'emulation_mode'] = opts[:'emulation_mode'] if !opts[:'emulation_mode'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(parse_model_message_request)

      # return_type
      return_type = opts[:debug_return_type] || 'ParseResult'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['JWT', 'TokenAuth']

      new_options = opts.merge(
        :operation => :"ModelApi.parse_model_message",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ModelApi#parse_model_message\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Predict an action on a temporary state
    # Predicts the next action on the tracker state as it is posted to this endpoint. Rasa will create a temporary tracker from the provided events and will use it to predict an action. No messages will be sent and no action will be run.
    # @param event [Array<Event>] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :include_events Specify which events of the tracker the response should contain. * &#x60;ALL&#x60; - every logged event. * &#x60;APPLIED&#x60; - only events that contribute to the trackers state. This excludes reverted utterances and actions that got undone. * &#x60;AFTER_RESTART&#x60; -  all events since the last &#x60;restarted&#x60; event.   This includes utterances that got reverted and actions that got undone.  * &#x60;NONE&#x60; - no events. (default to 'AFTER_RESTART')
    # @return [PredictResult]
    def predict_model_action(event, opts = {})
      data, _status_code, _headers = predict_model_action_with_http_info(event, opts)
      data
    end

    # Predict an action on a temporary state
    # Predicts the next action on the tracker state as it is posted to this endpoint. Rasa will create a temporary tracker from the provided events and will use it to predict an action. No messages will be sent and no action will be run.
    # @param event [Array<Event>] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :include_events Specify which events of the tracker the response should contain. * &#x60;ALL&#x60; - every logged event. * &#x60;APPLIED&#x60; - only events that contribute to the trackers state. This excludes reverted utterances and actions that got undone. * &#x60;AFTER_RESTART&#x60; -  all events since the last &#x60;restarted&#x60; event.   This includes utterances that got reverted and actions that got undone.  * &#x60;NONE&#x60; - no events. (default to 'AFTER_RESTART')
    # @return [Array<(PredictResult, Integer, Hash)>] PredictResult data, response status code and response headers
    def predict_model_action_with_http_info(event, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ModelApi.predict_model_action ...'
      end
      # verify the required parameter 'event' is set
      if @api_client.config.client_side_validation && event.nil?
        fail ArgumentError, "Missing the required parameter 'event' when calling ModelApi.predict_model_action"
      end
      allowable_values = ["ALL", "APPLIED", "AFTER_RESTART", "NONE"]
      if @api_client.config.client_side_validation && opts[:'include_events'] && !allowable_values.include?(opts[:'include_events'])
        fail ArgumentError, "invalid value for \"include_events\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/model/predict'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'include_events'] = opts[:'include_events'] if !opts[:'include_events'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(event)

      # return_type
      return_type = opts[:debug_return_type] || 'PredictResult'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['JWT', 'TokenAuth']

      new_options = opts.merge(
        :operation => :"ModelApi.predict_model_action",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ModelApi#predict_model_action\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Replace the currently loaded model
    # Updates the currently loaded model. First, tries to load the model from the local (note: local to Rasa server) storage system. Secondly, tries to load the model from the provided model server configuration. Last, tries to load the model from the provided remote storage.
    # @param model_request [ModelRequest] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def replace_model(model_request, opts = {})
      replace_model_with_http_info(model_request, opts)
      nil
    end

    # Replace the currently loaded model
    # Updates the currently loaded model. First, tries to load the model from the local (note: local to Rasa server) storage system. Secondly, tries to load the model from the provided model server configuration. Last, tries to load the model from the provided remote storage.
    # @param model_request [ModelRequest] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def replace_model_with_http_info(model_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ModelApi.replace_model ...'
      end
      # verify the required parameter 'model_request' is set
      if @api_client.config.client_side_validation && model_request.nil?
        fail ArgumentError, "Missing the required parameter 'model_request' when calling ModelApi.replace_model"
      end
      # resource path
      local_var_path = '/model'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(model_request)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['JWT', 'TokenAuth']

      new_options = opts.merge(
        :operation => :"ModelApi.replace_model",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ModelApi#replace_model\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Perform an intent evaluation
    # Evaluates NLU model against a model or using cross-validation.
    # @param body [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :model Model that should be used for evaluation. If the parameter is set, the model will be fetched with the currently loaded configuration setup. However, the currently loaded model will not be updated. The state of the server will not change. If the parameter is not set, the currently loaded model will be used for the evaluation.
    # @option opts [String] :callback_url If specified the call will return immediately with an empty response and status code 204. The actual result or any errors will be sent to the given callback URL as the body of a post request. (default to 'None')
    # @option opts [Integer] :cross_validation_folds 
    # @return [NLUEvaluationResult]
    def test_model_intent(body, opts = {})
      data, _status_code, _headers = test_model_intent_with_http_info(body, opts)
      data
    end

    # Perform an intent evaluation
    # Evaluates NLU model against a model or using cross-validation.
    # @param body [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :model Model that should be used for evaluation. If the parameter is set, the model will be fetched with the currently loaded configuration setup. However, the currently loaded model will not be updated. The state of the server will not change. If the parameter is not set, the currently loaded model will be used for the evaluation.
    # @option opts [String] :callback_url If specified the call will return immediately with an empty response and status code 204. The actual result or any errors will be sent to the given callback URL as the body of a post request. (default to 'None')
    # @option opts [Integer] :cross_validation_folds 
    # @return [Array<(NLUEvaluationResult, Integer, Hash)>] NLUEvaluationResult data, response status code and response headers
    def test_model_intent_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ModelApi.test_model_intent ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling ModelApi.test_model_intent"
      end
      # resource path
      local_var_path = '/model/test/intents'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'model'] = opts[:'model'] if !opts[:'model'].nil?
      query_params[:'callback_url'] = opts[:'callback_url'] if !opts[:'callback_url'].nil?
      query_params[:'cross_validation_folds'] = opts[:'cross_validation_folds'] if !opts[:'cross_validation_folds'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/x-yaml', 'application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'NLUEvaluationResult'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['JWT', 'TokenAuth']

      new_options = opts.merge(
        :operation => :"ModelApi.test_model_intent",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ModelApi#test_model_intent\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Evaluate stories
    # Evaluates one or multiple stories against the currently loaded Rasa model.
    # @param body [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :e2e Perform an end-to-end evaluation on the posted stories. (default to false)
    # @return [EvaluationStoriesResult]
    def test_model_stories(body, opts = {})
      data, _status_code, _headers = test_model_stories_with_http_info(body, opts)
      data
    end

    # Evaluate stories
    # Evaluates one or multiple stories against the currently loaded Rasa model.
    # @param body [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :e2e Perform an end-to-end evaluation on the posted stories. (default to false)
    # @return [Array<(EvaluationStoriesResult, Integer, Hash)>] EvaluationStoriesResult data, response status code and response headers
    def test_model_stories_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ModelApi.test_model_stories ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling ModelApi.test_model_stories"
      end
      # resource path
      local_var_path = '/model/test/stories'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'e2e'] = opts[:'e2e'] if !opts[:'e2e'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['text/yml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'EvaluationStoriesResult'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['JWT', 'TokenAuth']

      new_options = opts.merge(
        :operation => :"ModelApi.test_model_stories",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ModelApi#test_model_stories\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Train a Rasa model
    # Trains a new Rasa model. Depending on the data given only a dialogue model, only a NLU model, or a model combining a trained dialogue model with an NLU model will be trained. The new model is not loaded by default.
    # @param yaml_training_request [YAMLTrainingRequest] The training data should be in YAML format.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :save_to_default_model_directory  (default to true)
    # @option opts [Boolean] :force_training  (default to false)
    # @option opts [String] :augmentation  (default to '50')
    # @option opts [String] :num_threads  (default to '1')
    # @option opts [String] :callback_url If specified the call will return immediately with an empty response and status code 204. The actual result or any errors will be sent to the given callback URL as the body of a post request. (default to 'None')
    # @return [File]
    def train_model(yaml_training_request, opts = {})
      data, _status_code, _headers = train_model_with_http_info(yaml_training_request, opts)
      data
    end

    # Train a Rasa model
    # Trains a new Rasa model. Depending on the data given only a dialogue model, only a NLU model, or a model combining a trained dialogue model with an NLU model will be trained. The new model is not loaded by default.
    # @param yaml_training_request [YAMLTrainingRequest] The training data should be in YAML format.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :save_to_default_model_directory  (default to true)
    # @option opts [Boolean] :force_training  (default to false)
    # @option opts [String] :augmentation  (default to '50')
    # @option opts [String] :num_threads  (default to '1')
    # @option opts [String] :callback_url If specified the call will return immediately with an empty response and status code 204. The actual result or any errors will be sent to the given callback URL as the body of a post request. (default to 'None')
    # @return [Array<(File, Integer, Hash)>] File data, response status code and response headers
    def train_model_with_http_info(yaml_training_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ModelApi.train_model ...'
      end
      # verify the required parameter 'yaml_training_request' is set
      if @api_client.config.client_side_validation && yaml_training_request.nil?
        fail ArgumentError, "Missing the required parameter 'yaml_training_request' when calling ModelApi.train_model"
      end
      # resource path
      local_var_path = '/model/train'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'save_to_default_model_directory'] = opts[:'save_to_default_model_directory'] if !opts[:'save_to_default_model_directory'].nil?
      query_params[:'force_training'] = opts[:'force_training'] if !opts[:'force_training'].nil?
      query_params[:'augmentation'] = opts[:'augmentation'] if !opts[:'augmentation'].nil?
      query_params[:'num_threads'] = opts[:'num_threads'] if !opts[:'num_threads'].nil?
      query_params[:'callback_url'] = opts[:'callback_url'] if !opts[:'callback_url'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/octet-stream', 'application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(yaml_training_request)

      # return_type
      return_type = opts[:debug_return_type] || 'File'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['JWT', 'TokenAuth']

      new_options = opts.merge(
        :operation => :"ModelApi.train_model",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ModelApi#train_model\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Unload the trained model
    # Unloads the currently loaded trained model from the server.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def unload_model(opts = {})
      unload_model_with_http_info(opts)
      nil
    end

    # Unload the trained model
    # Unloads the currently loaded trained model from the server.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def unload_model_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: ModelApi.unload_model ...'
      end
      # resource path
      local_var_path = '/model'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['JWT', 'TokenAuth']

      new_options = opts.merge(
        :operation => :"ModelApi.unload_model",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: ModelApi#unload_model\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
