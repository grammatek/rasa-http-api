=begin
#Rasa - Server Endpoints

#The Rasa server provides endpoints to retrieve trackers of conversations as well as endpoints to modify them. Additionally, endpoints for training and testing models are provided.

The version of the OpenAPI document: 1.0.0

Generated by: https://openapi-generator.tech
OpenAPI Generator version: 6.2.1

=end

require 'cgi'

module Rasa::HTTP
  class TrackerApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Add a message to a tracker
    # Adds a message to a tracker. This doesn't trigger the prediction loop. It will log the message on the tracker and return, no actions will be predicted or run. This is often used together with the predict endpoint.
    # @param conversation_id [String] Id of the conversation
    # @param message [Message] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :include_events Specify which events of the tracker the response should contain. * &#x60;ALL&#x60; - every logged event. * &#x60;APPLIED&#x60; - only events that contribute to the trackers state. This excludes reverted utterances and actions that got undone. * &#x60;AFTER_RESTART&#x60; -  all events since the last &#x60;restarted&#x60; event.   This includes utterances that got reverted and actions that got undone.  * &#x60;NONE&#x60; - no events. (default to 'AFTER_RESTART')
    # @return [Tracker]
    def add_conversation_message(conversation_id, message, opts = {})
      data, _status_code, _headers = add_conversation_message_with_http_info(conversation_id, message, opts)
      data
    end

    # Add a message to a tracker
    # Adds a message to a tracker. This doesn&#39;t trigger the prediction loop. It will log the message on the tracker and return, no actions will be predicted or run. This is often used together with the predict endpoint.
    # @param conversation_id [String] Id of the conversation
    # @param message [Message] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :include_events Specify which events of the tracker the response should contain. * &#x60;ALL&#x60; - every logged event. * &#x60;APPLIED&#x60; - only events that contribute to the trackers state. This excludes reverted utterances and actions that got undone. * &#x60;AFTER_RESTART&#x60; -  all events since the last &#x60;restarted&#x60; event.   This includes utterances that got reverted and actions that got undone.  * &#x60;NONE&#x60; - no events. (default to 'AFTER_RESTART')
    # @return [Array<(Tracker, Integer, Hash)>] Tracker data, response status code and response headers
    def add_conversation_message_with_http_info(conversation_id, message, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TrackerApi.add_conversation_message ...'
      end
      # verify the required parameter 'conversation_id' is set
      if @api_client.config.client_side_validation && conversation_id.nil?
        fail ArgumentError, "Missing the required parameter 'conversation_id' when calling TrackerApi.add_conversation_message"
      end
      # verify the required parameter 'message' is set
      if @api_client.config.client_side_validation && message.nil?
        fail ArgumentError, "Missing the required parameter 'message' when calling TrackerApi.add_conversation_message"
      end
      allowable_values = ["ALL", "APPLIED", "AFTER_RESTART", "NONE"]
      if @api_client.config.client_side_validation && opts[:'include_events'] && !allowable_values.include?(opts[:'include_events'])
        fail ArgumentError, "invalid value for \"include_events\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/conversations/{conversation_id}/messages'.sub('{' + 'conversation_id' + '}', CGI.escape(conversation_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'include_events'] = opts[:'include_events'] if !opts[:'include_events'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(message)

      # return_type
      return_type = opts[:debug_return_type] || 'Tracker'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['JWT', 'TokenAuth']

      new_options = opts.merge(
        :operation => :"TrackerApi.add_conversation_message",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TrackerApi#add_conversation_message\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Append events to a tracker
    # Appends one or multiple new events to the tracker state of the conversation. Any existing events will be kept and the new events will be appended, updating the existing state. If events are appended to a new conversation ID, the tracker will be initialised with a new session.
    # @param conversation_id [String] Id of the conversation
    # @param add_conversation_tracker_events_request [AddConversationTrackerEventsRequest] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :include_events Specify which events of the tracker the response should contain. * &#x60;ALL&#x60; - every logged event. * &#x60;APPLIED&#x60; - only events that contribute to the trackers state. This excludes reverted utterances and actions that got undone. * &#x60;AFTER_RESTART&#x60; -  all events since the last &#x60;restarted&#x60; event.   This includes utterances that got reverted and actions that got undone.  * &#x60;NONE&#x60; - no events. (default to 'AFTER_RESTART')
    # @option opts [String] :output_channel The bot&#39;s utterances will be forwarded to this channel. It uses the credentials listed in &#x60;credentials.yml&#x60; to connect. In case the channel does not support this, the utterances will be returned in the response body. Use &#x60;latest&#x60; to try to send the messages to the latest channel the user used. Currently supported channels are listed in the permitted values for the parameter.
    # @option opts [Boolean] :execute_side_effects  (default to false)
    # @return [Tracker]
    def add_conversation_tracker_events(conversation_id, add_conversation_tracker_events_request, opts = {})
      data, _status_code, _headers = add_conversation_tracker_events_with_http_info(conversation_id, add_conversation_tracker_events_request, opts)
      data
    end

    # Append events to a tracker
    # Appends one or multiple new events to the tracker state of the conversation. Any existing events will be kept and the new events will be appended, updating the existing state. If events are appended to a new conversation ID, the tracker will be initialised with a new session.
    # @param conversation_id [String] Id of the conversation
    # @param add_conversation_tracker_events_request [AddConversationTrackerEventsRequest] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :include_events Specify which events of the tracker the response should contain. * &#x60;ALL&#x60; - every logged event. * &#x60;APPLIED&#x60; - only events that contribute to the trackers state. This excludes reverted utterances and actions that got undone. * &#x60;AFTER_RESTART&#x60; -  all events since the last &#x60;restarted&#x60; event.   This includes utterances that got reverted and actions that got undone.  * &#x60;NONE&#x60; - no events. (default to 'AFTER_RESTART')
    # @option opts [String] :output_channel The bot&#39;s utterances will be forwarded to this channel. It uses the credentials listed in &#x60;credentials.yml&#x60; to connect. In case the channel does not support this, the utterances will be returned in the response body. Use &#x60;latest&#x60; to try to send the messages to the latest channel the user used. Currently supported channels are listed in the permitted values for the parameter.
    # @option opts [Boolean] :execute_side_effects  (default to false)
    # @return [Array<(Tracker, Integer, Hash)>] Tracker data, response status code and response headers
    def add_conversation_tracker_events_with_http_info(conversation_id, add_conversation_tracker_events_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TrackerApi.add_conversation_tracker_events ...'
      end
      # verify the required parameter 'conversation_id' is set
      if @api_client.config.client_side_validation && conversation_id.nil?
        fail ArgumentError, "Missing the required parameter 'conversation_id' when calling TrackerApi.add_conversation_tracker_events"
      end
      # verify the required parameter 'add_conversation_tracker_events_request' is set
      if @api_client.config.client_side_validation && add_conversation_tracker_events_request.nil?
        fail ArgumentError, "Missing the required parameter 'add_conversation_tracker_events_request' when calling TrackerApi.add_conversation_tracker_events"
      end
      allowable_values = ["ALL", "APPLIED", "AFTER_RESTART", "NONE"]
      if @api_client.config.client_side_validation && opts[:'include_events'] && !allowable_values.include?(opts[:'include_events'])
        fail ArgumentError, "invalid value for \"include_events\", must be one of #{allowable_values}"
      end
      allowable_values = ["latest", "slack", "callback", "facebook", "rocketchat", "telegram", "twilio", "webexteams", "socketio"]
      if @api_client.config.client_side_validation && opts[:'output_channel'] && !allowable_values.include?(opts[:'output_channel'])
        fail ArgumentError, "invalid value for \"output_channel\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/conversations/{conversation_id}/tracker/events'.sub('{' + 'conversation_id' + '}', CGI.escape(conversation_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'include_events'] = opts[:'include_events'] if !opts[:'include_events'].nil?
      query_params[:'output_channel'] = opts[:'output_channel'] if !opts[:'output_channel'].nil?
      query_params[:'execute_side_effects'] = opts[:'execute_side_effects'] if !opts[:'execute_side_effects'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(add_conversation_tracker_events_request)

      # return_type
      return_type = opts[:debug_return_type] || 'Tracker'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['JWT', 'TokenAuth']

      new_options = opts.merge(
        :operation => :"TrackerApi.add_conversation_tracker_events",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TrackerApi#add_conversation_tracker_events\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Run an action in a conversation
    # DEPRECATED. Runs the action, calling the action server if necessary. Any responses sent by the executed action will be forwarded to the channel specified in the output_channel parameter. If no output channel is specified, any messages that should be sent to the user will be included in the response of this endpoint.
    # @param conversation_id [String] Id of the conversation
    # @param action_request [ActionRequest] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :include_events Specify which events of the tracker the response should contain. * &#x60;ALL&#x60; - every logged event. * &#x60;APPLIED&#x60; - only events that contribute to the trackers state. This excludes reverted utterances and actions that got undone. * &#x60;AFTER_RESTART&#x60; -  all events since the last &#x60;restarted&#x60; event.   This includes utterances that got reverted and actions that got undone.  * &#x60;NONE&#x60; - no events. (default to 'AFTER_RESTART')
    # @option opts [String] :output_channel The bot&#39;s utterances will be forwarded to this channel. It uses the credentials listed in &#x60;credentials.yml&#x60; to connect. In case the channel does not support this, the utterances will be returned in the response body. Use &#x60;latest&#x60; to try to send the messages to the latest channel the user used. Currently supported channels are listed in the permitted values for the parameter.
    # @return [ExecuteConversationAction200Response]
    def execute_conversation_action(conversation_id, action_request, opts = {})
      data, _status_code, _headers = execute_conversation_action_with_http_info(conversation_id, action_request, opts)
      data
    end

    # Run an action in a conversation
    # DEPRECATED. Runs the action, calling the action server if necessary. Any responses sent by the executed action will be forwarded to the channel specified in the output_channel parameter. If no output channel is specified, any messages that should be sent to the user will be included in the response of this endpoint.
    # @param conversation_id [String] Id of the conversation
    # @param action_request [ActionRequest] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :include_events Specify which events of the tracker the response should contain. * &#x60;ALL&#x60; - every logged event. * &#x60;APPLIED&#x60; - only events that contribute to the trackers state. This excludes reverted utterances and actions that got undone. * &#x60;AFTER_RESTART&#x60; -  all events since the last &#x60;restarted&#x60; event.   This includes utterances that got reverted and actions that got undone.  * &#x60;NONE&#x60; - no events. (default to 'AFTER_RESTART')
    # @option opts [String] :output_channel The bot&#39;s utterances will be forwarded to this channel. It uses the credentials listed in &#x60;credentials.yml&#x60; to connect. In case the channel does not support this, the utterances will be returned in the response body. Use &#x60;latest&#x60; to try to send the messages to the latest channel the user used. Currently supported channels are listed in the permitted values for the parameter.
    # @return [Array<(ExecuteConversationAction200Response, Integer, Hash)>] ExecuteConversationAction200Response data, response status code and response headers
    def execute_conversation_action_with_http_info(conversation_id, action_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TrackerApi.execute_conversation_action ...'
      end
      # verify the required parameter 'conversation_id' is set
      if @api_client.config.client_side_validation && conversation_id.nil?
        fail ArgumentError, "Missing the required parameter 'conversation_id' when calling TrackerApi.execute_conversation_action"
      end
      # verify the required parameter 'action_request' is set
      if @api_client.config.client_side_validation && action_request.nil?
        fail ArgumentError, "Missing the required parameter 'action_request' when calling TrackerApi.execute_conversation_action"
      end
      allowable_values = ["ALL", "APPLIED", "AFTER_RESTART", "NONE"]
      if @api_client.config.client_side_validation && opts[:'include_events'] && !allowable_values.include?(opts[:'include_events'])
        fail ArgumentError, "invalid value for \"include_events\", must be one of #{allowable_values}"
      end
      allowable_values = ["latest", "slack", "callback", "facebook", "rocketchat", "telegram", "twilio", "webexteams", "socketio"]
      if @api_client.config.client_side_validation && opts[:'output_channel'] && !allowable_values.include?(opts[:'output_channel'])
        fail ArgumentError, "invalid value for \"output_channel\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/conversations/{conversation_id}/execute'.sub('{' + 'conversation_id' + '}', CGI.escape(conversation_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'include_events'] = opts[:'include_events'] if !opts[:'include_events'].nil?
      query_params[:'output_channel'] = opts[:'output_channel'] if !opts[:'output_channel'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(action_request)

      # return_type
      return_type = opts[:debug_return_type] || 'ExecuteConversationAction200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['JWT', 'TokenAuth']

      new_options = opts.merge(
        :operation => :"TrackerApi.execute_conversation_action",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TrackerApi#execute_conversation_action\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve an end-to-end story corresponding to a conversation
    # The story represents the whole conversation in end-to-end format. This can be posted to the '/test/stories' endpoint and used as a test.
    # @param conversation_id [String] Id of the conversation
    # @param [Hash] opts the optional parameters
    # @option opts [Float] :_until All events previous to the passed timestamp will be replayed. Events that occur exactly at the target time will be included.
    # @option opts [Boolean] :all_sessions Whether to fetch all sessions in a conversation, or only the latest session * &#x60;true&#x60; - fetch all conversation sessions. * &#x60;false&#x60; - [default] fetch only the latest conversation session. (default to false)
    # @return [nil]
    def get_conversation_story(conversation_id, opts = {})
      get_conversation_story_with_http_info(conversation_id, opts)
      nil
    end

    # Retrieve an end-to-end story corresponding to a conversation
    # The story represents the whole conversation in end-to-end format. This can be posted to the &#39;/test/stories&#39; endpoint and used as a test.
    # @param conversation_id [String] Id of the conversation
    # @param [Hash] opts the optional parameters
    # @option opts [Float] :_until All events previous to the passed timestamp will be replayed. Events that occur exactly at the target time will be included.
    # @option opts [Boolean] :all_sessions Whether to fetch all sessions in a conversation, or only the latest session * &#x60;true&#x60; - fetch all conversation sessions. * &#x60;false&#x60; - [default] fetch only the latest conversation session. (default to false)
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def get_conversation_story_with_http_info(conversation_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TrackerApi.get_conversation_story ...'
      end
      # verify the required parameter 'conversation_id' is set
      if @api_client.config.client_side_validation && conversation_id.nil?
        fail ArgumentError, "Missing the required parameter 'conversation_id' when calling TrackerApi.get_conversation_story"
      end
      # resource path
      local_var_path = '/conversations/{conversation_id}/story'.sub('{' + 'conversation_id' + '}', CGI.escape(conversation_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'until'] = opts[:'_until'] if !opts[:'_until'].nil?
      query_params[:'all_sessions'] = opts[:'all_sessions'] if !opts[:'all_sessions'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/yml', 'application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['JWT', 'TokenAuth']

      new_options = opts.merge(
        :operation => :"TrackerApi.get_conversation_story",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TrackerApi#get_conversation_story\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve a conversations tracker
    # The tracker represents the state of the conversation. The state of the tracker is created by applying a sequence of events, which modify the state. These events can optionally be included in the response.
    # @param conversation_id [String] Id of the conversation
    # @param [Hash] opts the optional parameters
    # @option opts [String] :include_events Specify which events of the tracker the response should contain. * &#x60;ALL&#x60; - every logged event. * &#x60;APPLIED&#x60; - only events that contribute to the trackers state. This excludes reverted utterances and actions that got undone. * &#x60;AFTER_RESTART&#x60; -  all events since the last &#x60;restarted&#x60; event.   This includes utterances that got reverted and actions that got undone.  * &#x60;NONE&#x60; - no events. (default to 'AFTER_RESTART')
    # @option opts [Float] :_until All events previous to the passed timestamp will be replayed. Events that occur exactly at the target time will be included.
    # @return [Tracker]
    def get_conversation_tracker(conversation_id, opts = {})
      data, _status_code, _headers = get_conversation_tracker_with_http_info(conversation_id, opts)
      data
    end

    # Retrieve a conversations tracker
    # The tracker represents the state of the conversation. The state of the tracker is created by applying a sequence of events, which modify the state. These events can optionally be included in the response.
    # @param conversation_id [String] Id of the conversation
    # @param [Hash] opts the optional parameters
    # @option opts [String] :include_events Specify which events of the tracker the response should contain. * &#x60;ALL&#x60; - every logged event. * &#x60;APPLIED&#x60; - only events that contribute to the trackers state. This excludes reverted utterances and actions that got undone. * &#x60;AFTER_RESTART&#x60; -  all events since the last &#x60;restarted&#x60; event.   This includes utterances that got reverted and actions that got undone.  * &#x60;NONE&#x60; - no events. (default to 'AFTER_RESTART')
    # @option opts [Float] :_until All events previous to the passed timestamp will be replayed. Events that occur exactly at the target time will be included.
    # @return [Array<(Tracker, Integer, Hash)>] Tracker data, response status code and response headers
    def get_conversation_tracker_with_http_info(conversation_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TrackerApi.get_conversation_tracker ...'
      end
      # verify the required parameter 'conversation_id' is set
      if @api_client.config.client_side_validation && conversation_id.nil?
        fail ArgumentError, "Missing the required parameter 'conversation_id' when calling TrackerApi.get_conversation_tracker"
      end
      allowable_values = ["ALL", "APPLIED", "AFTER_RESTART", "NONE"]
      if @api_client.config.client_side_validation && opts[:'include_events'] && !allowable_values.include?(opts[:'include_events'])
        fail ArgumentError, "invalid value for \"include_events\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/conversations/{conversation_id}/tracker'.sub('{' + 'conversation_id' + '}', CGI.escape(conversation_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'include_events'] = opts[:'include_events'] if !opts[:'include_events'].nil?
      query_params[:'until'] = opts[:'_until'] if !opts[:'_until'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'Tracker'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['JWT', 'TokenAuth']

      new_options = opts.merge(
        :operation => :"TrackerApi.get_conversation_tracker",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TrackerApi#get_conversation_tracker\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Predict the next action
    # Runs the conversations tracker through the model's policies to predict the scores of all actions present in the model's domain. Actions are returned in the 'scores' array, sorted on their 'score' values. The state of the tracker is not modified.
    # @param conversation_id [String] Id of the conversation
    # @param [Hash] opts the optional parameters
    # @return [PredictResult]
    def predict_conversation_action(conversation_id, opts = {})
      data, _status_code, _headers = predict_conversation_action_with_http_info(conversation_id, opts)
      data
    end

    # Predict the next action
    # Runs the conversations tracker through the model&#39;s policies to predict the scores of all actions present in the model&#39;s domain. Actions are returned in the &#39;scores&#39; array, sorted on their &#39;score&#39; values. The state of the tracker is not modified.
    # @param conversation_id [String] Id of the conversation
    # @param [Hash] opts the optional parameters
    # @return [Array<(PredictResult, Integer, Hash)>] PredictResult data, response status code and response headers
    def predict_conversation_action_with_http_info(conversation_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TrackerApi.predict_conversation_action ...'
      end
      # verify the required parameter 'conversation_id' is set
      if @api_client.config.client_side_validation && conversation_id.nil?
        fail ArgumentError, "Missing the required parameter 'conversation_id' when calling TrackerApi.predict_conversation_action"
      end
      # resource path
      local_var_path = '/conversations/{conversation_id}/predict'.sub('{' + 'conversation_id' + '}', CGI.escape(conversation_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'PredictResult'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['JWT', 'TokenAuth']

      new_options = opts.merge(
        :operation => :"TrackerApi.predict_conversation_action",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TrackerApi#predict_conversation_action\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Replace a trackers events
    # Replaces all events of a tracker with the passed list of events. This endpoint should not be used to modify trackers in a production setup, but rather for creating training data.
    # @param conversation_id [String] Id of the conversation
    # @param event [Array<Event>] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :include_events Specify which events of the tracker the response should contain. * &#x60;ALL&#x60; - every logged event. * &#x60;APPLIED&#x60; - only events that contribute to the trackers state. This excludes reverted utterances and actions that got undone. * &#x60;AFTER_RESTART&#x60; -  all events since the last &#x60;restarted&#x60; event.   This includes utterances that got reverted and actions that got undone.  * &#x60;NONE&#x60; - no events. (default to 'AFTER_RESTART')
    # @return [Tracker]
    def replace_conversation_tracker_events(conversation_id, event, opts = {})
      data, _status_code, _headers = replace_conversation_tracker_events_with_http_info(conversation_id, event, opts)
      data
    end

    # Replace a trackers events
    # Replaces all events of a tracker with the passed list of events. This endpoint should not be used to modify trackers in a production setup, but rather for creating training data.
    # @param conversation_id [String] Id of the conversation
    # @param event [Array<Event>] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :include_events Specify which events of the tracker the response should contain. * &#x60;ALL&#x60; - every logged event. * &#x60;APPLIED&#x60; - only events that contribute to the trackers state. This excludes reverted utterances and actions that got undone. * &#x60;AFTER_RESTART&#x60; -  all events since the last &#x60;restarted&#x60; event.   This includes utterances that got reverted and actions that got undone.  * &#x60;NONE&#x60; - no events. (default to 'AFTER_RESTART')
    # @return [Array<(Tracker, Integer, Hash)>] Tracker data, response status code and response headers
    def replace_conversation_tracker_events_with_http_info(conversation_id, event, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TrackerApi.replace_conversation_tracker_events ...'
      end
      # verify the required parameter 'conversation_id' is set
      if @api_client.config.client_side_validation && conversation_id.nil?
        fail ArgumentError, "Missing the required parameter 'conversation_id' when calling TrackerApi.replace_conversation_tracker_events"
      end
      # verify the required parameter 'event' is set
      if @api_client.config.client_side_validation && event.nil?
        fail ArgumentError, "Missing the required parameter 'event' when calling TrackerApi.replace_conversation_tracker_events"
      end
      allowable_values = ["ALL", "APPLIED", "AFTER_RESTART", "NONE"]
      if @api_client.config.client_side_validation && opts[:'include_events'] && !allowable_values.include?(opts[:'include_events'])
        fail ArgumentError, "invalid value for \"include_events\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/conversations/{conversation_id}/tracker/events'.sub('{' + 'conversation_id' + '}', CGI.escape(conversation_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'include_events'] = opts[:'include_events'] if !opts[:'include_events'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(event)

      # return_type
      return_type = opts[:debug_return_type] || 'Tracker'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['JWT', 'TokenAuth']

      new_options = opts.merge(
        :operation => :"TrackerApi.replace_conversation_tracker_events",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TrackerApi#replace_conversation_tracker_events\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Inject an intent into a conversation
    # Sends a specified intent and list of entities in place of a user message. The bot then predicts and executes a response action. Any responses sent by the executed action will be forwarded to the channel specified in the ``output_channel`` parameter. If no output channel is specified, any messages that should be sent to the user will be included in the response of this endpoint.
    # @param conversation_id [String] Id of the conversation
    # @param intent_trigger_request [IntentTriggerRequest] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :include_events Specify which events of the tracker the response should contain. * &#x60;ALL&#x60; - every logged event. * &#x60;APPLIED&#x60; - only events that contribute to the trackers state. This excludes reverted utterances and actions that got undone. * &#x60;AFTER_RESTART&#x60; -  all events since the last &#x60;restarted&#x60; event.   This includes utterances that got reverted and actions that got undone.  * &#x60;NONE&#x60; - no events. (default to 'AFTER_RESTART')
    # @option opts [String] :output_channel The bot&#39;s utterances will be forwarded to this channel. It uses the credentials listed in &#x60;credentials.yml&#x60; to connect. In case the channel does not support this, the utterances will be returned in the response body. Use &#x60;latest&#x60; to try to send the messages to the latest channel the user used. Currently supported channels are listed in the permitted values for the parameter.
    # @return [ExecuteConversationAction200Response]
    def trigger_conversation_intent(conversation_id, intent_trigger_request, opts = {})
      data, _status_code, _headers = trigger_conversation_intent_with_http_info(conversation_id, intent_trigger_request, opts)
      data
    end

    # Inject an intent into a conversation
    # Sends a specified intent and list of entities in place of a user message. The bot then predicts and executes a response action. Any responses sent by the executed action will be forwarded to the channel specified in the &#x60;&#x60;output_channel&#x60;&#x60; parameter. If no output channel is specified, any messages that should be sent to the user will be included in the response of this endpoint.
    # @param conversation_id [String] Id of the conversation
    # @param intent_trigger_request [IntentTriggerRequest] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :include_events Specify which events of the tracker the response should contain. * &#x60;ALL&#x60; - every logged event. * &#x60;APPLIED&#x60; - only events that contribute to the trackers state. This excludes reverted utterances and actions that got undone. * &#x60;AFTER_RESTART&#x60; -  all events since the last &#x60;restarted&#x60; event.   This includes utterances that got reverted and actions that got undone.  * &#x60;NONE&#x60; - no events. (default to 'AFTER_RESTART')
    # @option opts [String] :output_channel The bot&#39;s utterances will be forwarded to this channel. It uses the credentials listed in &#x60;credentials.yml&#x60; to connect. In case the channel does not support this, the utterances will be returned in the response body. Use &#x60;latest&#x60; to try to send the messages to the latest channel the user used. Currently supported channels are listed in the permitted values for the parameter.
    # @return [Array<(ExecuteConversationAction200Response, Integer, Hash)>] ExecuteConversationAction200Response data, response status code and response headers
    def trigger_conversation_intent_with_http_info(conversation_id, intent_trigger_request, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: TrackerApi.trigger_conversation_intent ...'
      end
      # verify the required parameter 'conversation_id' is set
      if @api_client.config.client_side_validation && conversation_id.nil?
        fail ArgumentError, "Missing the required parameter 'conversation_id' when calling TrackerApi.trigger_conversation_intent"
      end
      # verify the required parameter 'intent_trigger_request' is set
      if @api_client.config.client_side_validation && intent_trigger_request.nil?
        fail ArgumentError, "Missing the required parameter 'intent_trigger_request' when calling TrackerApi.trigger_conversation_intent"
      end
      allowable_values = ["ALL", "APPLIED", "AFTER_RESTART", "NONE"]
      if @api_client.config.client_side_validation && opts[:'include_events'] && !allowable_values.include?(opts[:'include_events'])
        fail ArgumentError, "invalid value for \"include_events\", must be one of #{allowable_values}"
      end
      allowable_values = ["latest", "slack", "callback", "facebook", "rocketchat", "telegram", "twilio", "webexteams", "socketio"]
      if @api_client.config.client_side_validation && opts[:'output_channel'] && !allowable_values.include?(opts[:'output_channel'])
        fail ArgumentError, "invalid value for \"output_channel\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/conversations/{conversation_id}/trigger_intent'.sub('{' + 'conversation_id' + '}', CGI.escape(conversation_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'include_events'] = opts[:'include_events'] if !opts[:'include_events'].nil?
      query_params[:'output_channel'] = opts[:'output_channel'] if !opts[:'output_channel'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(intent_trigger_request)

      # return_type
      return_type = opts[:debug_return_type] || 'ExecuteConversationAction200Response'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['JWT', 'TokenAuth']

      new_options = opts.merge(
        :operation => :"TrackerApi.trigger_conversation_intent",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: TrackerApi#trigger_conversation_intent\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
